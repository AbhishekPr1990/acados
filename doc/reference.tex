\documentclass{report}

\usepackage{amsmath}
\usepackage{color}

\title{ACADOS / ACADO 2.0 / ??? \\ Reference}

\begin{document}

\maketitle

\chapter{Interfaces}

\section{OCP QP Interface}

The interface describes an Optimal Control Problem (OPC) Quadratic Programming (QP) problem in the form
\begin{align}
\min_{x,u} & \quad \sum_{n=0}^{N-1} \frac 1 2 \begin{bmatrix} u_n \\ x_n \\ 1 \end{bmatrix}^T \begin{bmatrix} R_n & S_n & r_n \\ S_n^T & Q_n & q_n \\ r_n^T & q_n^T & \end{bmatrix} \begin{bmatrix} u_n \\ x_n \\ 1 \end{bmatrix} + \frac 1 2 \begin{bmatrix} x_N \\ 1 \end{bmatrix}^T \begin{bmatrix} Q_N & q_N \\ q_N^T & \end{bmatrix} \begin{bmatrix} x_N \\ 1 \end{bmatrix} \\
s.t. & \quad x_{n+1} = A_n x_n + B_n u_n + b_n \quad , \quad n=0,\dots,N-1 \\
& \quad \underline u_n \leq u_n \leq \overline u_n \quad , \quad n=0,\dots,N-1 \\
& \quad \underline x_n \leq x_n \leq \overline x_n \quad , \quad n=0,\dots,N \\
& \quad \underline d_n \leq C_n x_n + D_n u_n \leq \overline d_n \quad , \quad n=0,\dots,N-1 \\
& \quad \underline d_N \leq C_N x_N \leq \overline d_N 
\end{align}

The C code interface looks like
\begin{verbatim}
int ocp_qp_SOLVERNAME(
    int N, int *nx, int *nu, int *nb, int *ng, 
    double **A, double **B, double **b, 
    double **Q, double **S, double **R, double **q, double **r, 
    int **idxb, double **lb, double **ub, 
    double **C, double **D, double **ld, double **ud, 
    double **x, double **u,
    struct ocp_qp_SOLVERNAME_args *args, double *work);
\end{verbatim}
where {\tt SOLVERNAME} is the name of the specific solver.
\begin{description}
\item[{\tt N}] [input] is the horizon length.
\item[{\tt nx}] [input] is the vector of the state sizes $n_u$ at the different stages, such that {\tt nx[n]} is the state size at stage {\tt n}.
\item[{\tt nu}] [input] is the vector of the input sizes $n_x$ at the different stages, such that {\tt nu[n]} is the input size at stage {\tt n}.
\item[{\tt nb}] [input] is the vector of the bound sizes $n_b$ at the different stages, such that {\tt nb[n]} is the bound size at stage {\tt n}.
The value of {\tt nb[n]} is smaller or equal to {\tt nx[n]+nu[n]}.
\item[{\tt ng}] [input] is the vector of the general polytopic constraint sizes $n_g$ at the different stages, such that {\tt ng[n]} is the general polytopic constraint size at stage {\tt n}.
\item[A] [input] is the vector of size $N$ of the pointers to the first element of the matrices $A_n$, such that {\tt A[n]} is the pointer to the first element of the matrix $A_n$, and {\tt A[n][0]} is the first element of the matrix $A_n$.
The matrix referenced by the pointer {\tt A[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nx[n+1]$\times$nx[n]} double-precision floating-point numbers.
\item[B] [input] is the vector of size $N$ of the pointers to the first element of the matrices $B_n$, such that {\tt B[n]} is the pointer to the first element of the matrix $B_n$, and {\tt B[n][0]} is the first element of the matrix $B_n$.
The matrix referenced by the pointer {\tt B[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nx[n+1]$\times$nu[n]} double-precision floating-point numbers.
\item[b] [input] is the vector of size $N$ of the pointers to the first element of the vectors $b_n$, such that {\tt b[n]} is the pointer to the first element of the vector $b_n$, and {\tt b[n][0]} is the first element of the vector $b_n$.
The vector referenced by the pointer {\tt b[n]} is stored in a vector of {\tt nx[n+1]$\times$1} double-precision floating-point numbers.
\item[Q] [input] is the vector of size $N+1$ of the pointers to the first element of the matrices $Q_n$, such that {\tt Q[n]} is the pointer to the first element of the matrix $Q_n$, and {\tt Q[n][0]} is the first element of the matrix $Q_n$.
The matrix referenced by the pointer {\tt Q[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nx[n]$\times$nx[n]} double-precision floating-point numbers.
\item[S] [input] is the vector of size $N$ of the pointers to the first element of the matrices $S_n$, such that {\tt S[n]} is the pointer to the first element of the matrix $S_n$, and {\tt S[n][0]} is the first element of the matrix $S_n$.
The matrix referenced by the pointer {\tt S[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nu[n]$\times$nx[n]} double-precision floating-point numbers.
\item[R] [input] is the vector of size $N$ of the pointers to the first element of the matrices $R_n$, such that {\tt R[n]} is the pointer to the first element of the matrix $R_n$, and {\tt R[n][0]} is the first element of the matrix $R_n$.
The matrix referenced by the pointer {\tt R[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nu[n]$\times$nu[n]} double-precision floating-point numbers.
\item[q] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $q_n$, such that {\tt q[n]} is the pointer to the first element of the vector $q_n$, and {\tt q[n][0]} is the first element of the vector $q_n$.
The vector referenced by the pointer {\tt q[n]} is stored in a vector of {\tt nx[n]$\times$1} double-precision floating-point numbers.
\item[r] [input] is the vector of size $N$ of the pointers to the first element of the vectors $r_n$, such that {\tt r[n]} is the pointer to the first element of the vector $r_n$, and {\tt r[n][0]} is the first element of the vector $r_n$.
The vector referenced by the pointer {\tt r[n]} is stored in a vector of {\tt nu[n]$\times$1} double-precision floating-point numbers.
\item[idxb] [input] is the vector of size $N+1$ of the pointers to the first element of the integer vectors $idxb_n$ describing the indexes of the corresponding upper and lower bounds in {\tt lb} and {\tt ub}, such that {\tt idxb[n]} is the pointer to the index of the first bound at stage $n$, and {\tt idxb[n][0]} is index of the first bound at stage $n$.
The indexes in {\tt idxb[n]} correspond to the position of the constrained components in the variables vector $\begin{bmatrix} u_n \\ x_n \end{bmatrix}$: therefore a bound on the first input component has index {\tt 0}, a bound on the last input component has index {\tt nu[n]-1}, a bound on the first state component has index {\tt nu[n]} and a bound on the last state component has index {\tt nu[n]+nx[n]-1}.
The vector referenced by the pointer {\tt idxb[n]} is stored in a vector of {\tt nb[n]$\times$1} integer numbers.
\item[lb] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\begin{bmatrix} \underline u_n \\ \underline x_n \end{bmatrix}$, such that {\tt lb[n]} is the pointer to the first element of the vector $\begin{bmatrix} \underline u_n \\ \underline x_n \end{bmatrix}$, and {\tt lb[n][0]} is the first element of the vector $\begin{bmatrix} \underline u_n \\ \underline x_n \end{bmatrix}$.
The vector referenced by the pointer {\tt lb[n]} is stored in a vector of {\tt nb[n]$\times$1} double-precision floating-point numbers.
\item[ub] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\begin{bmatrix} \overline u_n \\ \overline x_n \end{bmatrix}$, such that {\tt ub[n]} is the pointer to the first element of the vector $\begin{bmatrix} \overline u_n \\ \overline x_n \end{bmatrix}$, and {\tt ub[n][0]} is the first element of the vector $\begin{bmatrix} \overline u_n \\ \overline x_n \end{bmatrix}$.
The vector referenced by the pointer {\tt ub[n]} is stored in a vector of {\tt nb[n]$\times$1} double-precision floating-point numbers.
\item[C] [input] is the vector of size $N+1$ of the pointers to the first element of the matrices $C_n$, such that {\tt C[n]} is the pointer to the first element of the matrix $C_n$, and {\tt C[n][0]} is the first element of the matrix $C_n$.
The matrix referenced by the pointer {\tt C[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt ng[n]$\times$nx[n]} double-precision floating-point numbers.
\item[D] [input] is the vector of size $N$ of the pointers to the first element of the matrices $D_n$, such that {\tt D[n]} is the pointer to the first element of the matrix $D_n$, and {\tt D[n][0]} is the first element of the matrix $D_n$.
The matrix referenced by the pointer {\tt D[n]} is stored in column-major (or Fortran-like) order, in a vector of {\tt ng[n]$\times$nu[n]} double-precision floating-point numbers.
\item[ld] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\underline d_n$, such that {\tt ld[n]} is the pointer to the first element of the vector $\underline d_n$, and {\tt ld[n][0]} is the first element of the vector $\underline d_n$.
The vector referenced by the pointer {\tt ld[n]} is stored in a vector of {\tt ng[n]$\times$1} double-precision floating-point numbers.
\item[ud] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\overline d_n$, such that {\tt ud[n]} is the pointer to the first element of the vector $\overline d_n$, and {\tt ud[n][0]} is the first element of the vector $\overline d_n$.
The vector referenced by the pointer {\tt ud[n]} is stored in a vector of {\tt ng[n]$\times$1} double-precision floating-point numbers.
\item[x] [output] is the vector of size $N+1$ of the pointers to the first element of the vectors $x_n$, such that {\tt x[n]} is the pointer to the first element of the vector $x_n$, and {\tt x[n][0]} is the first element of the vector $x_n$.
The vector referenced by the pointer {\tt x[n]} is stored in a vector of {\tt nx[n]$\times$1} double-precision floating-point numbers.
\item[u] [output] is the vector of size $N+1$ of the pointers to the first element of the vectors $u_n$, such that {\tt u[n]} is the pointer to the first element of the vector $u_n$, and {\tt u[n][0]} is the first element of the vector $u_n$.
The vector referenced by the pointer {\tt u[n]} is stored in a vector of {\tt nu[n]$\times$1} double-precision floating-point numbers.
\item[args] [input] is the pointer to a structure of type {\tt ocp\_qp\_SOLVERNAME\_args} that defines the arguments (as e.g. maximum number of iterations, minimum step size, ... ) passed to the specific solver.
\item[work] [workspace] is the pointer to the working space used by the specific solver.
The working space size (in doubles) is returned by a call to the function {\tt ocp\_qp\_SOLVERNAME\_workspace\_double(int N, int *nx, int *nu, int *nb, int *ng, struct ocp\_qp\_solver\_args *args)}. 
\end{description}

Furthermore, the function returns an int, that is defined in the following enum (TODO change the names to something better!!!):
\begin{description}
\item[ACADOS\_SUCCESS] Solution successfully found.
\item[ACADOS\_MAXITER] Maximum number of iterations reached.
\item[ACADOS\_MINSTEP] Minumum step size reached (in IPs, probably unfeasible problem).
\end{description}

\subsection{Examples}

\subsubsection{MPC problem}

In the MPC problem, the initial state is fixed.
This is modelled by choosinig {\tt nx[0]=0}, i.e. not considering the initial state as an optimization variable.
As a consequence, e.g. the matrix {\tt A[0]} has size {\tt nx[1]$\times$0}, the matrix {\tt Q[0]} has size {\tt 0$\times$0}, and the vector {\tt q[0]} has size {\tt 0$\times$1}.
The information about the known value of $x_0$ and the matrix $A_0$ are used to compute the value of the vector {\tt b[0]}, that is initialized to $b_0 + A_0 \cdot x_0$.

\section{Integrator Interface with Sensitivity Propagation}

The C code interface looks like
\begin{verbatim}
int ocp_qp_SOLVERNAME(integrator_in *input, 
      struct integrator_SOLVERNAME_opts *opts, double *work);
\end{verbatim}
where the input struct is defined as:
\begin{verbatim}
typedef struct integrator_in_{
    int nSteps, int nSystems, int nX, int nXA, int nP, int nOD, 
    double *steps, int *nx, int *nxa, double **S0, double *mu,
    double **x, double **xa, double *p, double *od, double **xOut, 
    double **sensOut, double *muOut, double *hessOut, int nOutputs,
    int *nGridOutputs, double **gridOutputs, double **muOutputs, 
    double **valOutputs, double **sensOutputs, function_call *sys, 
    function_call *out, double *variables} integrator_in;
\end{verbatim}
where {\tt SOLVERNAME} is the name of the specific solver. Additionally, a function struct has been defined as:
\begin{verbatim}
typedef struct function_call_{
    int dimIn, int dimOut, bool *sparsity, bool linear, 
    void (*fun)(double*,double*), void (*jac)(double*,double*), 
    bool forward, bool backward, bool hessian,
    void (*vde_forw)(double*,double*), void (*vde_adj)(double*,double*),
    void (*vde_hess)(double*,double*)} function_call;
\end{verbatim}
If we like the latter embedding of structs, we can avoid some of the fields in the $integrator\_in$ struct by moving them somewhere else!

\begin{description}
\item[] \textcolor{red}{For fixed step integrators:}
\item[{\tt nSteps}] [input] is the number of integration steps (in case of no step size control).
\item[{\tt steps}] [input] is the vector of size $nSteps$, containing the step size for each integration step.
\item[] \textcolor{red}{Dimensions of the dynamic system(s):}
\item[{\tt nSystems}] [input] is the number of dynamic subsystems in order of dependency (states of subsystem $k$ only depend on subsystems $1,2,\ldots, k-1$ etc).
\item[{\tt flag\_linear}] [input] is the vector of size $nSystems$, containing the flag whether the subsystem is linear or not ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[{\tt nx}] [input] is the vector of size $nSystems$, containing the number of differential states for this integrator.
\item[{\tt nxa}] [input] is the vector of size $nSystems$, containing the number of algebraic states for this integrator.
\item[{\tt nX}] [input] is the {\bf total} number of differential states for this integrator.
\item[{\tt nXA}] [input] is the {\bf total} number of algebraic states for this integrator.
\item[{\tt nP}] [input] is the number of free parameters for this integrator (sensitivities with respect to these parameters are computed).
\item[{\tt nOD}] [input] is the number of online data, i.e. fixed parameters for this integrator (no sensitivities are computed).
\item[] \textcolor{red}{Sensitivity analysis for the integrator:}
\item[{\tt S0}] [input] is the vector of size $nSystems$ of the pointers to the matrices containing the forward seeds (the dimensions of these matrices are $nx[0] \times (nx[0]+np)$, $nx[1] \times (nx[0]+nx[1]+np)$, $\ldots$ etc).
\item[{\tt mu}] [input] is the vector of dimension $nX$, containing the backward seed.
\item[{\tt flag\_forward}] [input] is the flag for first order forward sensitivity propagation ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[{\tt flag\_backward}] [input] is the flag for first order backward sensitivity propagation ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[{\tt flag\_hessian}] [input] is the flag for second order Hessian propagation ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[] \textcolor{red}{Input and output data to the integrator:}
\item[{\tt x}] [input] is the vector of size $nSystems$ of the pointers to the initial values of the differential states for this integrator.
\item[{\tt xOut}] [output] is the vector of size $nSystems$ of the pointers to the end values of the differential states as a result of calling this integrator.
\item[{\tt sensOut}] [output] is the vector of size $nSystems$ of the pointers to the end values of the forward sensitivities as a result of calling this integrator.
\item[{\tt muOut}] [output] is the vector of size $nX+nP$ containing the backward derivatives as a result of calling this integrator.
\item[{\tt hessOut}] [output] is the matrix of size $(nX+nP) \times (nX+nP)p$ containing the second order derivatives as a result of calling this integrator.
\item[{\tt xa}] [input,output] is the vector of size $nSystems$ of the pointers to the initial {\bf guess} of the algebraic states for this integrator (the guess can be updated by the integrator).
\item[{\tt p}] [input] is the vector of size $nP$ containing the free parameters for this integrator (sensitivities can be computed).
\item[{\tt od}] [input] is the vector of size $nOD$ containing the online data, i.e. fixed parameters for this integrator (no sensitivities are computed).
\item[] \textcolor{red}{Extra outputs to be evaluated:}
\item[{\tt nOutputs}] [input] is the number of extra output functions (with each their own dimension).
\item[{\tt dimOutputs}] [input] is the vector of size $nOutputs$, containing the dimension for each of the output functions (moved to function\_call struct!).
\item[{\tt sparsityOutputs}] [input] is the matrix of dimension $nOutputs \times (nX+nXA+nX)$, defining the sparsity pattern for each output function with respect to the differential states, the algebraic variables and the state derivatives (moved to function\_call struct!).
\item[{\tt nGridOutputs}] [input] is the vector of size $nOutputs$, containing the number of grid points on which each output function should be evaluated.
\item[{\tt gridOutputs}] [input] is the vector of size $nOutputs$ of the pointers to the grid points on which each output function should be evaluated.
\item[{\tt muOutputs}] [input] is the vector of size $nOutputs$ of the pointers to the backward seeds for each of the grid points defined by $gridOutputs$.
\item[{\tt valOutputs}] [output] is the vector of size $nOutputs$ of the pointers to the outputs evaluated on the grid points defined by $gridOutputs$.
\item[{\tt sensOutputs}] [output] is the vector of size $nOutputs$ of the pointers to the forward sensitivities of the outputs evaluated on the grid points defined by $gridOutputs$.
\item[] \textcolor{red}{The functions (including AD) to be evaluated:}
\item[] (This changed using the  function\_call struct!!)
\item[{\tt rhs}] [input] the function pointer to evaluate the right-hand side.
\item[{\tt jac}] [input] the function pointer to evaluate the full Jacobian.
\item[{\tt vde\_forw}] [input] the function pointer to evaluate the forward variational differential equations.
\item[{\tt vde\_adj}] [input] the function pointer to evaluate the adjoint equations.
\item[{\tt vde\_hess}] [input] the function pointer to evaluate the second order sensitivity equations.
\item[{\tt out\_vde\_forw}] [input] is the vector of size $nOutputs$, containing the function pointers to evaluate the forward sensitivity equations for the outputs.
\item[{\tt out\_vde\_adj}] [input] is the vector of size $nOutputs$, containing the function pointers to evaluate the adjoint equations for the output functions.
\item[{\tt out\_vde\_hess}] [input] is the vector of size $nOutputs$, containing the function pointers to evaluate the second order sensitivity equations for the outputs.
\item[] \textcolor{red}{Other memory:}
\item[variables] [input,output] is the pointer to the warm variables space used by the specific solver from one call to the other.
The variables space size (in doubles) is returned by a call to the function \\{\tt integrator\_SOLVERNAME\_variables\_double(integrator\_in *input, struct integrator\_solver\_opts *opts)}. 
\item[opts] [input] is the pointer to a structure of type {\tt integrator\_SOLVERNAME\_opts} that defines the arguments (as e.g. maximum number of steps, minimum step size, desired tolerance, ... ) passed to the specific solver.
\item[work] [workspace] is the pointer to the working space used by the specific solver.
The working space size (in doubles) is returned by a call to the function {\tt integrator\_SOLVERNAME\_workspace\_double(integrator\_in *input, struct integrator\_solver\_opts *opts)}. 
\end{description}

Furthermore, the function returns an int, that is defined in the following enum (TODO change the names to something better!!!):
\begin{description}
\item[ACADOS\_SUCCESS] Solution successfully found.
\item[ACADOS\_MAXITER] Maximum number of integration steps reached.
\item[ACADOS\_MINSTEP] Minumum step size reached.
\end{description}

\end{document}
