\documentclass{report}

\usepackage{amsmath}
\usepackage{color}

\title{\texttt{acados} reference}

\begin{document}

\maketitle

\chapter{Interfaces}

\section{OCP QP interface}

This interface describes a Quadratic Programming (QP) problem with Optimal Control Problem (OCP) structure, as follows:
\begin{subequations}
	\begin{alignat}{3}
	\underset{\substack{x_0,\ldots,x_k \\ u_0,\ldots,u_{N-1}}}{\mathrm{minimize}} \quad & \sum_{k=0}^{N-1} \frac 1 2 \begin{bmatrix} x_k \\ u_k \end{bmatrix}^\top \begin{bmatrix} Q_k & S_k \\ S_k^\top & R_k \end{bmatrix} \begin{bmatrix} x_k \\ u_k \end{bmatrix} + &&\begin{bmatrix} q_k \\ r_k \end{bmatrix}^\top \begin{bmatrix} x_k \\ u_k \end{bmatrix} \\ & \qquad + \frac 1 2 x_N^\top Q_N x_N + q_N^\top x_N \nonumber \\
	\mathrm{subject~to} \quad & x_{k+1} = A_k x_k + B_k u_k + b_k, && k=0,\dots,N-1, \\
	& \underline u_k \leq u_k \leq \overline u_k, && k=0,\dots,N-1, \\
	& \underline x_k \leq x_k \leq \overline x_k, && k=0,\dots,N, \\
	& \underline c_k \leq C^x_k x_k + C^u_k u_k \leq \overline c_k, && k=0,\dots,N-1, \\
	& \underline c_N \leq C^x_N x_k \leq \overline c_N.
	\end{alignat}
\end{subequations}

The \texttt{C} interface looks like
\begin{verbatim}
int ocp_qp_SOLVERNAME(
    int N, int *nx, int *nu, int *nb, int *nc, 
    double **A, double **B, double **b, 
    double **Q, double **S, double **R, double **q, double **r, 
    int **idxb, double **lb, double **ub, 
    double **Cx, double **Cu, double **lc, double **uc, 
    double **x, double **u,
    struct ocp_qp_SOLVERNAME_args *args, double *work);
\end{verbatim}
where {\tt SOLVERNAME} is the name of the specific solver.
\begin{description}
\item[{\tt N}] [input] is the horizon length.
\item[{\tt nx}] [input] is the vector of the state sizes $n_u$ at the different stages, such that {\tt nx[k]} is the state size at stage {\tt k}.
\item[{\tt nu}] [input] is the vector of the input sizes $n_x$ at the different stages, such that {\tt nu[k]} is the input size at stage {\tt k}.
\item[{\tt nb}] [input] is the vector of the bound sizes $n_b$ at the different stages, such that {\tt nb[k]} is the bound size at stage {\tt k}.
The value of {\tt nb[k]} is smaller or equal to {\tt nx[k]+nu[k]}.
\item[{\tt nc}] [input] is the vector of the general polytopic constraint sizes $n_c$ at the different stages, such that {\tt nc[k]} is the general polytopic constraint size at stage {\tt k}.
\item[A] [input] is the vector of size $N$ of the pointers to the first element of the matrices $A_k$, such that {\tt A[k]} is the pointer to the first element of the matrix $A_k$, and {\tt A[k][0]} is the first element of the matrix $A_k$.
The matrix referenced by the pointer {\tt A[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nx[k+1]$\times$nx[k]} double-precision floating-point numbers.
\item[B] [input] is the vector of size $N$ of the pointers to the first element of the matrices $B_k$, such that {\tt B[k]} is the pointer to the first element of the matrix $B_k$, and {\tt B[k][0]} is the first element of the matrix $B_k$.
The matrix referenced by the pointer {\tt B[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nx[k+1]$\times$nu[k]} double-precision floating-point numbers.
\item[b] [input] is the vector of size $N$ of the pointers to the first element of the vectors $b_k$, such that {\tt b[k]} is the pointer to the first element of the vector $b_k$, and {\tt b[k][0]} is the first element of the vector $b_k$.
The vector referenced by the pointer {\tt b[k]} is stored in a vector of {\tt nx[k+1]$\times$1} double-precision floating-point numbers.
\item[Q] [input] is the vector of size $N+1$ of the pointers to the first element of the matrices $Q_k$, such that {\tt Q[k]} is the pointer to the first element of the matrix $Q_k$, and {\tt Q[k][0]} is the first element of the matrix $Q_k$.
The matrix referenced by the pointer {\tt Q[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nx[k]$\times$nx[k]} double-precision floating-point numbers.
\item[S] [input] is the vector of size $N$ of the pointers to the first element of the matrices $S_k$, such that {\tt S[k]} is the pointer to the first element of the matrix $S_k$, and {\tt S[k][0]} is the first element of the matrix $S_k$.
The matrix referenced by the pointer {\tt S[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nu[k]$\times$nx[k]} double-precision floating-point numbers.
\item[R] [input] is the vector of size $N$ of the pointers to the first element of the matrices $R_k$, such that {\tt R[k]} is the pointer to the first element of the matrix $R_k$, and {\tt R[k][0]} is the first element of the matrix $R_k$.
The matrix referenced by the pointer {\tt R[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nu[k]$\times$nu[k]} double-precision floating-point numbers.
\item[q] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $q_k$, such that {\tt q[k]} is the pointer to the first element of the vector $q_k$, and {\tt q[k][0]} is the first element of the vector $q_k$.
The vector referenced by the pointer {\tt q[k]} is stored in a vector of {\tt nx[k]$\times$1} double-precision floating-point numbers.
\item[r] [input] is the vector of size $N$ of the pointers to the first element of the vectors $r_k$, such that {\tt r[k]} is the pointer to the first element of the vector $r_k$, and {\tt r[k][0]} is the first element of the vector $r_k$.
The vector referenced by the pointer {\tt r[k]} is stored in a vector of {\tt nu[k]$\times$1} double-precision floating-point numbers.
\item[idxb] [input] is the vector of size $N+1$ of the pointers to the first element of the integer vectors $\mathrm{idxb}_k$ describing the indexes of the corresponding upper and lower bounds in {\tt lb} and {\tt ub}, such that {\tt idxb[k]} is the pointer to the index of the first bound at stage $k$, and {\tt idxb[k][0]} is index of the first bound at stage $k$.
The indexes in {\tt idxb[k]} correspond to the position of the constrained components in the variables vector $\begin{bmatrix} x_k \\ u_k \end{bmatrix}$: therefore a bound on the first state component has index {\tt 0}, a bound on the last state component has index {\tt nx[k]-1}, a bound on the first input component has index {\tt nx[k]} and a bound on the last input component has index {\tt nx[k]+nu[k]-1}.
The vector referenced by the pointer {\tt idxb[k]} is stored in a vector of {\tt nb[k]$\times$1} integer numbers.
\item[lb] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\begin{bmatrix} \underline x_k \\ \underline u_k \end{bmatrix}$, such that {\tt lb[k]} is the pointer to the first element of the vector $\begin{bmatrix} \underline x_k \\ \underline u_k \end{bmatrix}$, and {\tt lb[k][0]} is the first element of the vector $\begin{bmatrix} \underline x_k \\ \underline u_k \end{bmatrix}$.
The vector referenced by the pointer {\tt lb[k]} is stored in a vector of {\tt nb[k]$\times$1} double-precision floating-point numbers.
\item[ub] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\begin{bmatrix} \overline x_k \\ \overline u_k \end{bmatrix}$, such that {\tt ub[k]} is the pointer to the first element of the vector $\begin{bmatrix} \overline x_k \\ \overline u_k \end{bmatrix}$, and {\tt ub[k][0]} is the first element of the vector $\begin{bmatrix} \overline x_k \\ \overline u_k \end{bmatrix}$.
The vector referenced by the pointer {\tt ub[k]} is stored in a vector of {\tt nb[k]$\times$1} double-precision floating-point numbers.
\item[Cx] [input] is the vector of size $N+1$ of the pointers to the first element of the matrices $C^x_k$, such that {\tt Cx[k]} is the pointer to the first element of the matrix $C^x_k$, and {\tt Cx[k][0]} is the first element of the matrix $C^x_k$.
The matrix referenced by the pointer {\tt Dx[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nc[k]$\times$nx[k]} double-precision floating-point numbers.
\item[Cu] [input] is the vector of size $N$ of the pointers to the first element of the matrices $C^u_k$, such that {\tt Cu[k]} is the pointer to the first element of the matrix $C^u_k$, and {\tt Cu[k][0]} is the first element of the matrix $C^u_k$.
The matrix referenced by the pointer {\tt Cu[k]} is stored in column-major (or Fortran-like) order, in a vector of {\tt nc[k]$\times$nu[k]} double-precision floating-point numbers.
\item[ld] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\underline c_k$, such that {\tt lc[k]} is the pointer to the first element of the vector $\underline c_k$, and {\tt ld[k][0]} is the first element of the vector $\underline c_k$.
The vector referenced by the pointer {\tt ld[k]} is stored in a vector of {\tt nc[k]$\times$1} double-precision floating-point numbers.
\item[ud] [input] is the vector of size $N+1$ of the pointers to the first element of the vectors $\overline c_k$, such that {\tt uc[k]} is the pointer to the first element of the vector $\overline c_k$, and {\tt uc[k][0]} is the first element of the vector $\overline c_k$.
The vector referenced by the pointer {\tt uc[k]} is stored in a vector of {\tt nc[k]$\times$1} double-precision floating-point numbers.
\item[x] [output] is the vector of size $N+1$ of the pointers to the first element of the vectors $x_k$, such that {\tt x[k]} is the pointer to the first element of the vector $x_k$, and {\tt x[k][0]} is the first element of the vector $x_k$.
The vector referenced by the pointer {\tt x[k]} is stored in a vector of {\tt nx[k]$\times$1} double-precision floating-point numbers.
\item[u] [output] is the vector of size $N+1$ of the pointers to the first element of the vectors $u_k$, such that {\tt u[k]} is the pointer to the first element of the vector $u_k$, and {\tt u[k][0]} is the first element of the vector $u_k$.
The vector referenced by the pointer {\tt u[k]} is stored in a vector of {\tt nu[k]$\times$1} double-precision floating-point numbers.
\item[args] [input] is the pointer to a structure of type {\tt ocp\_qp\_SOLVERNAME\_args} that defines the arguments (as e.g. maximum number of iterations, minimum step size, ... ) passed to the specific solver.
\item[work] [workspace] is the pointer to the working space used by the specific solver.
The working space size (in doubles) is returned by a call to the function {\tt ocp\_qp\_SOLVERNAME\_workspace\_double(int N, int *nx, int *nu, int *nb, int *nc, struct ocp\_qp\_solver\_args *args)}. 
\end{description}

Furthermore, the function returns an int, that is defined in the following enum (TODO change the names to something better!!!):
\begin{description}
\item[ACADOS\_SUCCESS] Solution successfully found.
\item[ACADOS\_MAXITER] Maximum number of iterations reached.
\item[ACADOS\_MINSTEP] Minumum step size reached (in IPs, probably unfeasible problem).
\end{description}

\subsection{Examples}

\subsubsection{MPC problem}

In the MPC problem, the initial state is fixed.
This can be modeled by choosing {\tt nx[0]=0}, i.e. not considering the initial state as an optimization variable.
As a consequence, e.g. the matrix {\tt A[0]} has size {\tt nx[1]$\times$0}, the matrix {\tt Q[0]} has size {\tt 0$\times$0}, and the vector {\tt q[0]} has size {\tt 0$\times$1}.
The information about the known value of $x_0$ and the matrix $A_0$ are used to compute the value of the vector {\tt b[0]}, that is initialized to $b_0 + A_0 \cdot x_0$.

\section{Condensing Interface}

This is the interface to the condensing routine, first discovered in~\cite{Bock1984}. The notation used here is partly based on~\cite{Frasch2014a}.

\begin{verbatim}
int condensing_NAME(condensing_in *input, condensing_out *output,
        condensing_memory *mem, condensing_workspace *work);
\end{verbatim}

The condensing function relies on different structures, explained next.

\begin{description}
	\item[input] The input struct has a number of fields
\end{description}

\section{Integrator Interface with Sensitivity Propagation}

The C code interface looks like
\begin{verbatim}
int ocp_qp_NAME(integrator_in *input, 
      struct integrator_NAME_opts *opts, double *work);
\end{verbatim}
where the input struct is defined as:
\begin{verbatim}
typedef struct integrator_in_{
    int nSteps, int nSystems, int nX, int nXA, int nP, int nOD, 
    double *steps, int *nx, int *nxa, double **S0, double *mu,
    double **x, double **xa, double *p, double *od, double **xOut, 
    double **sensOut, double *muOut, double *hessOut, int nOutputs,
    int *nGridOutputs, double **gridOutputs, double **muOutputs, 
    double **valOutputs, double **sensOutputs, function_call *sys, 
    function_call *out, double *variables} integrator_in;
\end{verbatim}
where {\tt NAME} is the name of the specific integration routine. Additionally, a function struct has been defined as:
\begin{verbatim}
typedef struct function_call_{
    int dimIn, int dimOut, bool *sparsity, bool linear, 
    void (*fun)(double*,double*), void (*jac)(double*,double*), 
    bool forward, bool backward, bool hessian,
    void (*vde_forw)(double*,double*), void (*vde_adj)(double*,double*),
    void (*vde_hess)(double*,double*)} function_call;
\end{verbatim}
If we like the latter embedding of structs, we can avoid some of the fields in the $integrator\_in$ struct by moving them somewhere else!

\begin{description}
\item[] \textcolor{red}{For fixed step integrators:}
\item[{\tt nSteps}] [input] is the number of integration steps (in case of no step size control).
\item[{\tt steps}] [input] is the vector of size $nSteps$, containing the step size for each integration step.
\item[] \textcolor{red}{Dimensions of the dynamic system(s):}
\item[{\tt nSystems}] [input] is the number of dynamic subsystems in order of dependency (states of subsystem $k$ only depend on subsystems $1,2,\ldots, k-1$ etc).
\item[{\tt flag\_linear}] [input] is the vector of size $nSystems$, containing the flag whether the subsystem is linear or not ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[{\tt nx}] [input] is the vector of size $nSystems$, containing the number of differential states for this integrator.
\item[{\tt nxa}] [input] is the vector of size $nSystems$, containing the number of algebraic states for this integrator.
\item[{\tt nX}] [input] is the {\bf total} number of differential states for this integrator.
\item[{\tt nXA}] [input] is the {\bf total} number of algebraic states for this integrator.
\item[{\tt nP}] [input] is the number of free parameters for this integrator (sensitivities with respect to these parameters are computed).
\item[{\tt nOD}] [input] is the number of online data, i.e. fixed parameters for this integrator (no sensitivities are computed).
\item[] \textcolor{red}{Sensitivity analysis for the integrator:}
\item[{\tt S0}] [input] is the vector of size $nSystems$ of the pointers to the matrices containing the forward seeds (the dimensions of these matrices are $nx[0] \times (nx[0]+np)$, $nx[1] \times (nx[0]+nx[1]+np)$, $\ldots$ etc).
\item[{\tt mu}] [input] is the vector of dimension $nX$, containing the backward seed.
\item[{\tt flag\_forward}] [input] is the flag for first order forward sensitivity propagation ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[{\tt flag\_backward}] [input] is the flag for first order backward sensitivity propagation ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[{\tt flag\_hessian}] [input] is the flag for second order Hessian propagation ($0$ or $1$, should be part of options OR see the function\_call struct).
\item[] \textcolor{red}{Input and output data to the integrator:}
\item[{\tt x}] [input] is the vector of size $nSystems$ of the pointers to the initial values of the differential states for this integrator.
\item[{\tt xOut}] [output] is the vector of size $nSystems$ of the pointers to the end values of the differential states as a result of calling this integrator.
\item[{\tt sensOut}] [output] is the vector of size $nSystems$ of the pointers to the end values of the forward sensitivities as a result of calling this integrator.
\item[{\tt muOut}] [output] is the vector of size $nX+nP$ containing the backward derivatives as a result of calling this integrator.
\item[{\tt hessOut}] [output] is the matrix of size $(nX+nP) \times (nX+nP)p$ containing the second order derivatives as a result of calling this integrator.
\item[{\tt xa}] [input,output] is the vector of size $nSystems$ of the pointers to the initial {\bf guess} of the algebraic states for this integrator (the guess can be updated by the integrator).
\item[{\tt p}] [input] is the vector of size $nP$ containing the free parameters for this integrator (sensitivities can be computed).
\item[{\tt od}] [input] is the vector of size $nOD$ containing the online data, i.e. fixed parameters for this integrator (no sensitivities are computed).
\item[] \textcolor{red}{Extra outputs to be evaluated:}
\item[{\tt nOutputs}] [input] is the number of extra output functions (with each their own dimension).
\item[{\tt dimOutputs}] [input] is the vector of size $nOutputs$, containing the dimension for each of the output functions (moved to function\_call struct!).
\item[{\tt sparsityOutputs}] [input] is the matrix of dimension $nOutputs \times (nX+nXA+nX)$, defining the sparsity pattern for each output function with respect to the differential states, the algebraic variables and the state derivatives (moved to function\_call struct!).
\item[{\tt nGridOutputs}] [input] is the vector of size $nOutputs$, containing the number of grid points on which each output function should be evaluated.
\item[{\tt gridOutputs}] [input] is the vector of size $nOutputs$ of the pointers to the grid points on which each output function should be evaluated.
\item[{\tt muOutputs}] [input] is the vector of size $nOutputs$ of the pointers to the backward seeds for each of the grid points defined by $gridOutputs$.
\item[{\tt valOutputs}] [output] is the vector of size $nOutputs$ of the pointers to the outputs evaluated on the grid points defined by $gridOutputs$.
\item[{\tt sensOutputs}] [output] is the vector of size $nOutputs$ of the pointers to the forward sensitivities of the outputs evaluated on the grid points defined by $gridOutputs$.
\item[] \textcolor{red}{The functions (including AD) to be evaluated:}
\item[] (This changed using the  function\_call struct!!)
\item[{\tt rhs}] [input] the function pointer to evaluate the right-hand side.
\item[{\tt jac}] [input] the function pointer to evaluate the full Jacobian.
\item[{\tt vde\_forw}] [input] the function pointer to evaluate the forward variational differential equations.
\item[{\tt vde\_adj}] [input] the function pointer to evaluate the adjoint equations.
\item[{\tt vde\_hess}] [input] the function pointer to evaluate the second order sensitivity equations.
\item[{\tt out\_vde\_forw}] [input] is the vector of size $nOutputs$, containing the function pointers to evaluate the forward sensitivity equations for the outputs.
\item[{\tt out\_vde\_adj}] [input] is the vector of size $nOutputs$, containing the function pointers to evaluate the adjoint equations for the output functions.
\item[{\tt out\_vde\_hess}] [input] is the vector of size $nOutputs$, containing the function pointers to evaluate the second order sensitivity equations for the outputs.
\item[] \textcolor{red}{Other memory:}
\item[variables] [input,output] is the pointer to the warm variables space used by the specific solver from one call to the other.
The variables space size (in doubles) is returned by a call to the function \\{\tt integrator\_NAME\_variables\_double(integrator\_in *input, struct integrator\_solver\_opts *opts)}. 
\item[opts] [input] is the pointer to a structure of type {\tt integrator\_NAME\_opts} that defines the arguments (as e.g. maximum number of steps, minimum step size, desired tolerance, ... ) passed to the specific solver.
\item[work] [workspace] is the pointer to the working space used by the specific solver.
The working space size (in doubles) is returned by a call to the function {\tt integrator\_NAME\_workspace\_double(integrator\_in *input, struct integrator\_solver\_opts *opts)}. 
\end{description}

Furthermore, the function returns an int, that is defined in the following enum (TODO change the names to something better!!!):
\begin{description}
\item[ACADOS\_SUCCESS] Solution successfully found.
\item[ACADOS\_MAXITER] Maximum number of integration steps reached.
\item[ACADOS\_MINSTEP] Minumum step size reached.
\end{description}

\bibliographystyle{abbrv}
\bibliography{./syscop.bib}


\end{document}
