/************************************************
* ocp_nlp_cost_external
************************************************/

// ext cost

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = work->ext_cost_in+0; // ux: nu+nx

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = work->ext_cost_out+0; // grad: nu+nx
ext_fun_type_out[1] = COLMAJ;
ext_fun_out[1] = work->ext_cost_out+nx+nu; // hess: (nu+nx) * (nu+nx)

model->ext_cost->evaluate(model->ext_cost, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);



/************************************************
* ocp_nlp_cost_nls
************************************************/

// nls_jac

ext_fun_type_in[0] = BLASFEO_DVEC;
ext_fun_in[0] = memory->ux; // ux: nu+nx

ext_fun_type_out[0] = BLASFEO_DVEC;
ext_fun_out[0] = &memory->res; // fun: ny
ext_fun_type_out[1] = BLASFEO_DMAT;
ext_fun_out[1] = &memory->Jt; // jac': (nu+nx) * ny

model->nls_jac->evaluate(model->nls_jac, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);


// nls_jac

ext_fun_type_in[0] = BLASFEO_DVEC;
ext_fun_in[0] = memory->ux; // ux: nu+nx
ext_fun_type_in[1] = BLASFEO_DVEC;
ext_fun_in[1] = &work->tmp_ny; // fun: ny

ext_fun_type_out[0] = BLASFEO_DMAT;
ext_fun_out[0] = memory->RSQrq; // hess: (nu+nx) * (nu+nx)

model->nls_hess->evaluate(model->nls_hess, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);



/************************************************
* ocp_nlp_constraints
************************************************/

// h

//
ext_fun_type_in[0] = BLASFEO_DVEC;
ext_fun_in[0] = memory->ux; // ux: nu+nx

//
ext_fun_type_out[0] = BLASFEO_DVEC_ARGS;
struct blasfeo_dvec_args h_args;
h_args.x = &work->tmp_nbgh;
h_args.xi = nb+ng;
ext_fun_out[0] = &h_args; // fun: nh
//
ext_fun_type_out[1] = BLASFEO_DMAT_ARGS;
struct blasfeo_dmat_args Jht_args;
Jht_args.A = memory->DCt;
Jht_args.ai = 0;
Jht_args.aj = ng;
ext_fun_out[1] = &Jht_args; // jac': (nu+nx) * nh

model->h->evaluate(model->h, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);



/************************************************
* sim_erk_integrator
************************************************/

// expl_vde_for

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = rhs_forw_in+0; // x: nx
ext_fun_type_in[1] = COLMAJ;
ext_fun_in[1] = rhs_forw_in+nx; // Sx: nx*nx
ext_fun_type_in[2] = COLMAJ;
ext_fun_in[2] = rhs_forw_in+nx+nx*nx; // Su: nx*nu
ext_fun_type_in[3] = COLMAJ;
ext_fun_in[3] = rhs_forw_in+nx+nx*nx+nx*nu; // u: nu

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = K_traj+s*nX+0; // fun: nx
ext_fun_type_out[1] = COLMAJ;
ext_fun_out[1] = K_traj+s*nX+nx; // Sx: nx*nx
ext_fun_type_out[2] = COLMAJ;
ext_fun_out[2] = K_traj+s*nX+nx+nx*nx; // Su: nx*nu

model->expl_vde_for->evaluate(model->expl_vde_for, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);


// expl_ode_fun

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = rhs_forw_in+0; // x: nx
ext_fun_type_in[1] = COLMAJ;
ext_fun_in[1] = rhs_forw_in+nx; // u: nu

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = K_traj+s*nX+0; // fun: nx

model->expl_ode_fun->evaluate(model->expl_ode_fun, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);


// expl_ode_hess

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = rhs_adj_in+0; // x: nx
ext_fun_type_in[1] = COLMAJ;
ext_fun_in[1] = rhs_adj_in+nx; // lam: nx
ext_fun_type_in[2] = COLMAJ;
ext_fun_in[2] = rhs_adj_in+nx+nx; // u: nu

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = adj_traj+s*nAdj+0; // adj: nx+nu

model->expl_ode_hes->evaluate(model->expl_ode_hes, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);


// expl_vde_adj

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = rhs_adj_in+0; // x: nx
ext_fun_type_in[1] = COLMAJ;
ext_fun_in[1] = rhs_adj_in+nx; // Sx: nx*nx
ext_fun_type_in[2] = COLMAJ;
ext_fun_in[2] = rhs_adj_in+nx+nx*nx; // Su: nx*nu
ext_fun_type_in[3] = COLMAJ;
ext_fun_in[3] = rhs_adj_in+nx+nx*nx+nx*nu; // lam: nx
ext_fun_type_in[4] = COLMAJ;
ext_fun_in[4] = rhs_adj_in+nx+nx*nx+nx*nu+nx; // u: nu

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = adj_traj+s*nAdj+0; // adj: nx+nu
ext_fun_type_out[1] = COLMAJ;
ext_fun_out[1] = adj_traj+s*nAdj+nx+nu; // hess: (nx+nu)*(nx+nu)

model->expl_vde_adj->evaluate(model->expl_vde_adj, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);




/************************************************
* sim_lifted_irk_integrator
************************************************/

// expl_ode_jac

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = rhs_in+0; // x: nx
ext_fun_type_in[1] = COLMAJ;
ext_fun_in[1] = rhs_in+nx; // u: nu

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = jac_tmp+0; // fun: nx
ext_fun_type_out[1] = COLMAJ;
ext_fun_out[1] = jac_tmp+nx; // jac_x: nx*nx

model->expl_ode_jac->evaluate(model->expl_ode_jac, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);


// expl_vde_for

ext_fun_type_in[0] = COLMAJ;
ext_fun_in[0] = rhs_in+0; // x: nx
ext_fun_type_in[1] = COLMAJ;
ext_fun_in[1] = rhs_in+nx; // Sx: nx*nx
ext_fun_type_in[2] = COLMAJ;
ext_fun_in[2] = rhs_in+nx+nx*nx; // Su: nx*nu
ext_fun_type_in[3] = COLMAJ;
ext_fun_in[3] = rhs_in+nx+nx*nx+nx*nu; // u: nu

ext_fun_type_out[0] = COLMAJ;
ext_fun_out[0] = VDE_tmp[s1]+0; // fun: nx
ext_fun_type_out[1] = COLMAJ;
ext_fun_out[1] = VDE_tmp[s1]+nx; // Sx: nx*nx
ext_fun_type_out[2] = COLMAJ;
ext_fun_out[2] = VDE_tmp[s1]+nx+nx*nx; // Su: nx*nu

model->expl_vde_for->evaluate(model->expl_vde_for, ext_fun_type_in, ext_fun_in, ext_fun_type_out, ext_fun_out);



/************************************************
* sim_irk_integrator
************************************************/

// INPUT: impl_ode // NOTE: this is the input for all impl_ode_* functions
ext_fun_arg_t impl_ode_type_in[3];
void *impl_ode_in[3];

impl_ode_type_in[0] = BLASFEO_DVEC; // xt
impl_ode_type_in[1] = BLASFEO_DVEC_ARGS; // k_i
impl_ode_type_in[2] = COLMAJ; // u

struct blasfeo_dvec_args impl_ode_xdot_in;

impl_ode_in[0] = xt; // 1st input is always xt
impl_ode_in[1] = &impl_ode_xdot_in; // 2nd input is part of K[ss], always update impl_ode_xdot_in
impl_ode_in[2] = u; // 3rd input is u (always)

// hereby xt is the current approximation of the integrator of the state, calculated as:
blasfeo_dveccp(nx, xn, 0, xt, 0);
for(jj=0; jj<ns; jj++)
{ // jj-th col of tableau
    a = A_mat[ii+ns*jj];
    if(a!=0)
    {           // xt = xt + T_int * a[i,j]*K_j
        a *= step;
        blasfeo_daxpy(nx, a, K, jj*nx, xt, 0, xt, 0);
    }
}

// impl_ode_xdot_in gets modified before each function call, see the lines:
impl_ode_xdot_in.x = K;
impl_ode_xdot_in.xi = ii*nx; // use k_i of K = (k_1,..., k_{ns})


// OUTPUT: One ext_fun_arg_t for each type of output: fun, jac_x, jac_xdot, jac_u.
//      we use J_temp_u,... to cache the jacobians of a stage and;
//      the residual is always directly inserted in the blasfeo_dvec rG, the corresponding subvector is set by the line:
//                      impl_ode_res_out.xi = ii*nx; // store output in this posistion of rG

// impl_ode_fun
ext_fun_arg_t impl_ode_fun_type_out[1];
void *impl_ode_fun_out[1];
impl_ode_fun_type_out[0] = BLASFEO_DVEC_ARGS;

struct blasfeo_dvec_args impl_ode_res_out;
impl_ode_res_out.x = rG;

impl_ode_fun_out[0] = &impl_ode_res_out;

// impl_ode_fun_jac_x_xdot
ext_fun_arg_t impl_ode_fun_jac_x_xdot_type_out[3];
void *impl_ode_fun_jac_x_xdot_out[3];
impl_ode_fun_jac_x_xdot_type_out[0] = BLASFEO_DVEC_ARGS;
impl_ode_fun_jac_x_xdot_out[0] = &impl_ode_res_out;
impl_ode_fun_jac_x_xdot_type_out[1] = BLASFEO_DMAT;
impl_ode_fun_jac_x_xdot_out[1] = &J_temp_x;
impl_ode_fun_jac_x_xdot_type_out[2] = BLASFEO_DMAT;
impl_ode_fun_jac_x_xdot_out[2] = &J_temp_xdot; // jac_xdot: nx*nx

// impl_ode_jac_x_xdot_u
ext_fun_arg_t impl_ode_jac_x_xdot_u_type_out[3];
void *impl_ode_jac_x_xdot_u_out[3];
impl_ode_jac_x_xdot_u_type_out[0] = BLASFEO_DMAT;
impl_ode_jac_x_xdot_u_out[0] = &J_temp_x;
impl_ode_jac_x_xdot_u_type_out[1] = BLASFEO_DMAT;
impl_ode_jac_x_xdot_u_out[1] = &J_temp_xdot;
impl_ode_jac_x_xdot_u_type_out[2] = BLASFEO_DMAT;
impl_ode_jac_x_xdot_u_out[2] = &J_temp_u;
irk_model *model = in->model;


// Function Generation in casadi:
//      for an example look into examples/c/crane_model/model.m;
// NOTE: outputs are concatenated as:
// impl_ode_jac_x_xdot_u = Function('casadi_impl_ode_jac_x_xdot_u', {x, x_dot, u}, {jac_x, jac_xdot, jac_u});
// NOT (!!!) as sometimes in earlier version:
// impl_ode_jac_x_xdot_u = Function('casadi_impl_ode_jac_x_xdot_u', {x, x_dot, u}, {[jac_x, jac_xdot, jac_u]});

