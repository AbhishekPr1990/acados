function [ s ] = prepare_struct_exploiting_sim(s,opts)
tic
    import casadi.*
    nx1 = s.nx1; nx = s.nx; nu = s.nu; nz = s.nz; n_out = s.n_out;
    I_stages = eye( opts.n_stages );
    %generate submatrices
    E11 = s.E(1:nx1, 1:nx1);
    E12 = s.E(1:nx1, 1+nx1:nx1+nz);
    E21 = s.E(1+nx1:nx1+nz, 1:nx1);
    E22 = s.E(1+nx1:nx1+nz, 1+nx1:nx1+nz);
    
    A1 = s.A(1:nx1, :); A2 = s.A(nx1+1:nx1+nz, :);
    B1 = s.B(1:nx1, :); B2 = s.B(nx1+1:nx1+nz, :);
    C1 = s.C(1:nx1, :); C2 = s.C(nx1+1:nx1+nz, :);
    
    % generate fat matrices
    AA1 = repmat(A1,opts.n_stages,1);
    AA2 = repmat(A2,opts.n_stages,1);
    BB1 = repmat(B1,opts.n_stages,1);
    BB2 = repmat(B2,opts.n_stages,1);
    CC1 = kron(I_stages,C1);
    CC2 = kron(I_stages,C2);
    DD1 = -kron(I_stages, E12);
    DD2 = opts.dt * kron(opts.A_butcher, A2) - kron(I_stages, E21);
    EE1 = kron(I_stages, E11) - opts.dt * kron(opts.A_butcher, A1);
    EE2 = kron(I_stages, E22);
    
    % needed to get K-values from f,u,x
    EE1inv = inv(EE1);
    EE2inv = inv(EE2);
    
    PP1 = inv(eye(nx1*opts.n_stages) - EE1inv * DD1 * EE2inv  * DD2); 
    PP2 = EE1inv * DD1 * EE2inv;
    KKf = PP1 * ( PP2 * CC2 + EE1inv * CC1);
    KKu = PP1 * ( PP2 * BB2 + EE1inv * BB1);
    KKx = PP1 * ( PP2 * AA2 + EE1inv * AA1);
    
    % to get Z-values
    ZZf = EE2inv * (DD2 * KKf + CC2);
    ZZu = EE2inv * (DD2 * KKu + BB2);
    ZZx = EE2inv * (DD2 * KKx + AA2);
      
    % needed for linear output system:
    M2 = eye( s.nx2 * opts.n_stages);
    M2 =  M2 - kron( opts.dt * opts.A_butcher, s.ALO);
    M2inv = M2^-1;
    

    % put precomputed matrices in struct
    s.KKf = KKf;
    s.KKu = KKu;
    s.KKx = KKx;
    
    s.ZZf = ZZf;
    s.ZZu = ZZu;
    s.ZZx = ZZx;
    
    % generate residual function
    ff = SX.sym('ff', n_out * opts.n_stages,1);
    x1_init = SX.sym('x1_init', nx1, 1);
    u_in = SX.sym('u_in', nu, 1);
%     keyboard
    K1 = KKf * ff + KKu * u_in + KKx * x1_init;
    Z  = ZZf * ff + ZZu * u_in + ZZx * x1_init;
    stageval = kron(opts.A_dt, eye(nx1)) * K1 + repmat( x1_init, opts.n_stages, 1);
    res = SX.sym('res', opts.n_stages * n_out ,1);
    for ii = 1 : opts.n_stages
        ind_out = index( n_out, ii);
        ind_x1  = index( nx1,   ii);
        ind_z   = index( nz ,   ii);
        res( ind_out,1 ) = ff(ind_out) - s.Phi_fun( K1( ind_x1 ), stageval(ind_x1), Z(ind_z), u_in);
    end
    res_fun = Function('res_fun', {ff, x1_init, u_in}, {res});
    jac_res_ff = jacobian(res, ff);
    jac_res_ff_fun = Function('jac_res_ff_fun', {ff, x1_init, u_in}, {jac_res_ff});
    
    res_inc_Jff = [res, jac_res_ff];
    res_inc_Jff = res_inc_Jff(:);
    size(res_inc_Jff)
    
    res_inc_Jff_fun = Function('res_inc_Jff_fun', {ff, x1_init, u_in}, {res_inc_Jff});
    % jac_res_ffx1u = jacobian(res, [ff; x1_init; u_in]);
    % this is more efficient, because of backward AD
    jac_res_ffx1u = transpose(jtimes(res, [ff; x1_init; u_in], eye(opts.n_stages * n_out), true));

    jac_res_ffx1u_fun = Function('jac_res_ffx1u_fun',{ff, x1_init, u_in}, {jac_res_ffx1u});
    
    s.res_fun = res_fun;
    s.jac_res_ff_fun = jac_res_ff_fun;
    s.jac_res_ffx1u_fun = jac_res_ffx1u_fun;
    
    s.res_inc_Jff_fun = res_inc_Jff_fun;
    
    stageval_fun = Function('stageval_fun', {ff, x1_init, u_in}, {stageval});
    
    s.stageval_fun = stageval_fun;
    
% TODO check linear system again
    s.M2inv = M2inv;
    
    s.dK2_dx2 = M2inv * repmat(s.ALO,opts.n_stages,1);
    
    disp(['time in prepare_nlf = ',num2str(toc)]);
end